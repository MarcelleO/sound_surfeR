---
title: "sound_surfeR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
  )

```

*collaborators: Landon B. Porter & Marcelle E. Olvera* 

#Background

Automatic acoustic analysis allows for a passive method to analyze acoustic recording. Manually scored data collection is not exempt from human error and inter-rater reliability is rarely a perfect match. Subsequently, manually scoring data is time consuming when hours of data are collected. Commonly available Bio acoustic software is proprietary which makes R an appealing option with an open-source software repository.

Automatic acoustic analysis can be feasible through the use of feature extraction. The monitor package performs automatic acoustic template matching via two algorithm approaches, spectrogram cross correlation and binary point matching. 

*Limitation to the cross-correlation approach: a high signal to noise ratio is required. As a results, cross correlation may be appropriate for audio recorded in a lab setting, but not in a field setting. 

Binary point matching plots out ‘on’ and ‘off’ points on a sound template. All values with an amplitude equal or greater than the threshold get a value of 1, and all values below the threshold get a value of 0 The output score represents the difference in mean on point and off point amplitudes.

Spectrogram cross correlation contains location points. The scores are based off Pearson’s correlation coefficient.


#Viewing Spectrographs

In this package, we include a sample data set, “data” containing three distinct sounds and one ‘unknown’ audio as the novel ‘test’ audio. Using the sample data set, we walk through one of the available methods for automatic template matching, binary match point. 

Each audio file can be viewed using the viewSpec() function. The viewSpec() function arguments include a data source, a frequency limit, a start time, and a

```{r}
library(monitoR)

viewSpec(survey, frq.lim=c(2, 9), start.time=7.5, page.length=4)
```

The viewSpec() function also has an interactive feature after setting the argument to true, interactive=TRUE . The interactive spectrograph allows for zooming in and out or slide along the x-axis.Annotation of multiple sounds of interest is possible by setting the annotate argument in viewSpec() to true, annotate=TRUE, within the interactive spectrograph console. 

annos <- viewSpec(survey, interactive=TRUE, annotate=TRUE)

#Template Creation

Template creation can be one of the most important steps in getting the best results from this process. These templates serve as the comparison points for the new audio to be analyzed.
Templates can be created using three methods, Automatic, rectangular area selection, and point selection. Each one with increasing accuracy for capturing the desired sound of interest.

Here we will walk through the automatic binary point match method of template creation.
We will extract our template audios from one data file. Assign a data file path then index the desired wav files from the chosen file to create a template using the makeBinTemplate() function.

Notice that the more templates created for one sound improve the accuracy of template matching.

The makeCorTemplate() function similarly makes templates for the Spectrograph cross correlation method.

```{r}
#template 1 for beep sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[1])
beep1 <- makeBinTemplate(fileList[1], frq.lim = c(3, 6), t.lim = c(0, .7), name = "3beep1", amp.cutoff = (-25))


#template 2 for beep sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[2])
beep2 <- makeBinTemplate(fileList[2], frq.lim = c(3, 6), t.lim = c(0, .7), name = "3beep2", amp.cutoff = (-25))


#template 1 for clap sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[4])
clap1 <- makeBinTemplate(fileList[4], frq.lim = c(0.1, 6), t.lim = c(0, .5), name = "clap1", amp.cutoff = (-25))

#template 2 for clap sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[5])
clap2 <- makeBinTemplate(fileList[5], frq.lim = c(0.1, 6), t.lim = c(0, .5), name = "clap2", amp.cutoff = (-25))

#template 1 for note sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[7])
note1 <- makeBinTemplate(fileList[7], frq.lim = c(0.9, 1.2), t.lim = c(0, 1), name = "note1", amp.cutoff = (-48))

#template 2 for note sound 
fileList <- list.files(path = "D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data", full.names = TRUE)
sunwave <-  readWave(fileList[8])
note2 <- makeBinTemplate(fileList[8], frq.lim = c(0.9, 1.2), t.lim = c(0, 1), name = "note2", amp.cutoff = (-40))

```

#Template list
Templates can be put into lists. This makes it plausible to match the novel audio to multiple templates at once. In the following code, we create a template for binary point matching using the 

```{r}
#Create a bin with the templates you want to use for automatic matching. 
tempbin <- combineBinTemplates(beep1, beep2, clap1, clap2) 
tempbin
```

#Matching

The matching process consists of a template repeatedly scored for similarity against a moving window of the audio using the corMatch and binMatch functions.

You must first assign a file path 

```{r}
beep3 <- file.path("D:/BACK-UP'/documents'/UT AUSTIN/Spring 2022/ANT388 (R-coding)/sound_surfer/data/3beep3.wav")
```

